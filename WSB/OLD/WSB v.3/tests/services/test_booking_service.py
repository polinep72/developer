# tests/services/test_booking_service.py

import pytest
from unittest.mock import MagicMock, call, patch # Добавили patch
from datetime import date, time, datetime, timedelta
import datetime as dt_original # Используем для MockDateTime
import logging

# Импортируем сервисы и константы
from services import booking_service
import constants as const
# Импортируем user_service и equipment_service для мокинга, если нужно
from services import user_service, equipment_service

log = logging.getLogger("TestBookingService") # Отдельный логгер для тестов

TEST_EQUIPMENT_ID = 1
DEFAULT_DATE = date(2024, 5, 15)
DEFAULT_DATE_STR = "15-05-2024"
TEST_USER_ID = 100
TEST_ADMIN_ID = 999
TEST_OTHER_USER_ID = 101

# --- Мокинг datetime.now() ---
class MockDateTime(dt_original.datetime):
    _mock_now = None
    @classmethod
    def set_now(cls, dt_to_set):
        if not isinstance(dt_to_set, dt_original.datetime):
            raise TypeError(f"MockDateTime.set_now ожидает datetime, получил {type(dt_to_set)}")
        cls._mock_now = dt_to_set
        log.debug(f"MockDateTime.now установлен на: {cls._mock_now}")
    @classmethod
    def now(cls, tz=None):
        dt_now = cls._mock_now if cls._mock_now else dt_original.datetime.now(tz)
        log.debug(f"MockDateTime.now() вызван, возвращает: {dt_now}")
        return dt_now
    @classmethod
    def reset_now(cls):
        log.debug(f"MockDateTime.now сброшен (был: {cls._mock_now})")
        cls._mock_now = None

@pytest.fixture(autouse=True)
def auto_mock_datetime_now(mocker):
    """Автоматически патчит datetime.datetime на MockDateTime."""
    mock = mocker.patch('services.booking_service.datetime', MockDateTime)
    yield mock
    MockDateTime.reset_now() # Сбрасываем после теста

# --- Фикстура для мока DB ---
@pytest.fixture
def mock_db(mocker):
    """Фикстура для создания мока Database."""
    try:
        # Используем класс Database для type hinting в моке
        from database import Database
    except ImportError:
        Database = object # Fallback, если Database не найден
    return mocker.Mock(spec=Database)

# --- Тестовые данные для бронирований (словари) ---
BOOKING_ID_FUTURE = 501
BOOKING_ID_PAST = 502
BOOKING_ID_CANCELLED = 503
BOOKING_ID_FINISHED = 504
BOOKING_ID_OTHER_USER = 505
BOOKING_NOT_FOUND_ID = 9999
BOOKING_ID_ACTIVE_NOW = 506
BOOKING_ID_TO_EXTEND = 507

MOCK_BOOKING_FUTURE = {'id': BOOKING_ID_FUTURE, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'date': date(2024,5,16), 'time_start': dt_original.datetime(2024, 5, 16, 10, 0), 'time_end': dt_original.datetime(2024, 5, 16, 11, 0), 'cancel': False, 'finish': None, 'equipment_name': 'Тест Обор.', 'user_fi': 'Тест Тестов'}
MOCK_BOOKING_PAST = {'id': BOOKING_ID_PAST, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'date': date(2024,5,15), 'time_start': dt_original.datetime(2024, 5, 15, 9, 0), 'time_end': dt_original.datetime(2024, 5, 15, 10, 0), 'cancel': False, 'finish': None, 'equipment_name': 'Тест Обор.', 'user_fi': 'Тест Тестов'}
MOCK_BOOKING_CANCELLED = {'id': BOOKING_ID_CANCELLED, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'date': date(2024,5,16), 'time_start': dt_original.datetime(2024, 5, 16, 12, 0), 'time_end': dt_original.datetime(2024, 5, 16, 13, 0), 'cancel': True, 'finish': None, 'equipment_name': 'Тест Обор.', 'user_fi': 'Тест Тестов'}
MOCK_BOOKING_FINISHED = {'id': BOOKING_ID_FINISHED, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'date': date(2024,5,14), 'time_start': dt_original.datetime(2024, 5, 14, 10, 0), 'time_end': dt_original.datetime(2024, 5, 14, 11, 0), 'cancel': False, 'finish': dt_original.datetime(2024, 5, 14, 10, 55), 'equipment_name': 'Тест Обор.', 'user_fi': 'Тест Тестов'} # finish - datetime
MOCK_BOOKING_OTHER_USER = {'id': BOOKING_ID_OTHER_USER, 'user_id': TEST_OTHER_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'date': date(2024,5,16), 'time_start': dt_original.datetime(2024, 5, 16, 14, 0), 'time_end': dt_original.datetime(2024, 5, 16, 15, 0), 'cancel': False, 'finish': None, 'equipment_name': 'Тест Обор.', 'user_fi': 'Другой Другов'}
MOCK_BOOKING_ACTIVE_NOW = {'id': BOOKING_ID_ACTIVE_NOW, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'date': date(2024,5,15), 'time_start': dt_original.datetime(2024, 5, 15, 11, 0), 'time_end': dt_original.datetime(2024, 5, 15, 12, 0), 'cancel': False, 'finish': None, 'equipment_name': 'Активное Обор.', 'user_fi': 'Тест Тестов'}
MOCK_BOOKING_TO_EXTEND = {'id': BOOKING_ID_TO_EXTEND, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'date': date(2024,5,15), 'time_start': dt_original.datetime(2024, 5, 15, 14, 0), 'time_end': dt_original.datetime(2024, 5, 15, 15, 0), 'cancel': False, 'finish': None, 'equipment_name': 'Продлеваемое Обор.', 'user_fi': 'Тест Тестов'}
MOCK_BOOKING_CONFLICTING_EXTENSION = {'id': 601, 'user_id': TEST_OTHER_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'time_start': dt_original.datetime(2024, 5, 15, 15, 30), 'time_end': dt_original.datetime(2024, 5, 15, 16, 0), 'cancel': False, 'finish': None, 'equipment_name': 'Конфликт', 'user_fi': 'Конфликтующий Юзер'}

# --- Тесты для calculate_available_slots ---
# (Тесты calculate_available_slots остаются без изменений, они выглядят корректно)
def test_calculate_slots_empty_day(mocker, mock_db, caplog): caplog.set_level(logging.INFO); mock_booking_data = []; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, DEFAULT_DATE); expected_slots = [(const.WORKING_HOURS_START, const.WORKING_HOURS_END)]; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, DEFAULT_DATE)
def test_calculate_slots_single_booking_middle(mocker, mock_db, caplog): caplog.set_level(logging.INFO); booking_start_dt = dt_original.datetime.combine(DEFAULT_DATE, time(11, 0)); booking_end_dt = dt_original.datetime.combine(DEFAULT_DATE, time(12, 30)); mock_booking_data = [{'equip_id': TEST_EQUIPMENT_ID, 'time_start': booking_start_dt, 'time_end': booking_end_dt, 'id': 100}]; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, DEFAULT_DATE); expected_slots = [(const.WORKING_HOURS_START, time(11, 0)), (time(12, 30), const.WORKING_HOURS_END)]; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, DEFAULT_DATE)
def test_calculate_slots_booking_at_start(mocker, mock_db, caplog): caplog.set_level(logging.INFO); booking_start_dt = dt_original.datetime.combine(DEFAULT_DATE, const.WORKING_HOURS_START); booking_end_dt = booking_start_dt + timedelta(minutes=const.BOOKING_TIME_STEP_MINUTES * 2); mock_booking_data = [{'equip_id': TEST_EQUIPMENT_ID, 'time_start': booking_start_dt, 'time_end': booking_end_dt, 'id': 101}]; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, DEFAULT_DATE); expected_slots = [(booking_end_dt.time(), const.WORKING_HOURS_END)]; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, DEFAULT_DATE)
def test_calculate_slots_booking_at_end(mocker, mock_db, caplog): caplog.set_level(logging.INFO); booking_end_dt = dt_original.datetime.combine(DEFAULT_DATE, const.WORKING_HOURS_END); booking_start_dt = booking_end_dt - timedelta(minutes=const.BOOKING_TIME_STEP_MINUTES * 3); mock_booking_data = [{'equip_id': TEST_EQUIPMENT_ID, 'time_start': booking_start_dt, 'time_end': booking_end_dt, 'id': 102}]; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, DEFAULT_DATE); expected_slots = [(const.WORKING_HOURS_START, booking_start_dt.time())]; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, DEFAULT_DATE)
def test_calculate_slots_multiple_bookings(mocker, mock_db, caplog): caplog.set_level(logging.INFO); b1_start = dt_original.datetime.combine(DEFAULT_DATE, time(9, 0)); b1_end = dt_original.datetime.combine(DEFAULT_DATE, time(10, 0)); b2_start = dt_original.datetime.combine(DEFAULT_DATE, time(12, 0)); b2_end = dt_original.datetime.combine(DEFAULT_DATE, time(13, 30)); b3_start = dt_original.datetime.combine(DEFAULT_DATE, time(13, 30)); b3_end = dt_original.datetime.combine(DEFAULT_DATE, time(15, 0)); b4_start = dt_original.datetime.combine(DEFAULT_DATE, time(16, 0)); b4_end = dt_original.datetime.combine(DEFAULT_DATE, time(17, 0)); mock_booking_data = [{'equip_id': TEST_EQUIPMENT_ID, 'time_start': b1_start, 'time_end': b1_end, 'id': 201}, {'equip_id': TEST_EQUIPMENT_ID, 'time_start': b2_start, 'time_end': b2_end, 'id': 202}, {'equip_id': TEST_EQUIPMENT_ID, 'time_start': b3_start, 'time_end': b3_end, 'id': 203}, {'equip_id': 99, 'time_start': b4_start, 'time_end': b4_end, 'id': 999}]; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, DEFAULT_DATE); expected_slots = [(const.WORKING_HOURS_START, time(9, 0)), (time(10, 0), time(12, 0)), (time(15, 0), const.WORKING_HOURS_END)]; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, DEFAULT_DATE)
def test_calculate_slots_gap_too_short(mocker, mock_db, caplog): caplog.set_level(logging.INFO); gap_minutes = const.BOOKING_TIME_STEP_MINUTES - 5; pytest.skip(f"Шаг бронирования ({const.BOOKING_TIME_STEP_MINUTES} мин) слишком мал.") if gap_minutes <= 0 else None; b1_start = dt_original.datetime.combine(DEFAULT_DATE, time(10, 0)); b1_end = dt_original.datetime.combine(DEFAULT_DATE, time(11, 0)); b2_start = b1_end + timedelta(minutes=gap_minutes); b2_end = b2_start + timedelta(hours=1); mock_booking_data = [{'equip_id': TEST_EQUIPMENT_ID, 'time_start': b1_start, 'time_end': b1_end, 'id': 301}, {'equip_id': TEST_EQUIPMENT_ID, 'time_start': b2_start, 'time_end': b2_end, 'id': 302}]; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, DEFAULT_DATE); expected_slots = [(const.WORKING_HOURS_START, time(10, 0)), (b2_end.time(), const.WORKING_HOURS_END)]; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, DEFAULT_DATE)
def test_calculate_slots_today_adjust_start(mocker, mock_db, caplog): caplog.set_level(logging.INFO); mock_now_dt = dt_original.datetime(2024, 5, 15, 9, 48, 30); today_date = mock_now_dt.date(); MockDateTime.set_now(mock_now_dt); mock_booking_data = []; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); step = const.BOOKING_TIME_STEP_MINUTES; minutes_to_add = step - (mock_now_dt.minute % step) if mock_now_dt.minute % step != 0 else 0; minutes_to_add = step if minutes_to_add == 0 and (mock_now_dt.second > 0 or mock_now_dt.microsecond > 0) else minutes_to_add; expected_start_dt = (mock_now_dt + timedelta(minutes=minutes_to_add)).replace(second=0, microsecond=0); expected_start_time = expected_start_dt.time(); expected_start_time = const.WORKING_HOURS_START if expected_start_time < const.WORKING_HOURS_START else expected_start_time; result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, today_date); expected_slots = [(expected_start_time, const.WORKING_HOURS_END)]; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, today_date)
def test_calculate_slots_today_slot_already_passed(mocker, mock_db, caplog): caplog.set_level(logging.DEBUG); log.info("--- test_calculate_slots_today_slot_already_passed ---"); mock_now_dt = dt_original.datetime(2024, 5, 15, 11, 15, 0); today_date = mock_now_dt.date(); MockDateTime.set_now(mock_now_dt); log.debug(f"Patched services.booking_service.datetime with MockDateTime"); booking_start_dt = dt_original.datetime.combine(today_date, time(14, 0)); booking_end_dt = dt_original.datetime.combine(today_date, time(15, 0)); mock_booking_data = [{'equip_id': TEST_EQUIPMENT_ID, 'time_start': booking_start_dt, 'time_end': booking_end_dt, 'id': 401}]; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); step = const.BOOKING_TIME_STEP_MINUTES; minutes_to_add = step - (mock_now_dt.minute % step) if mock_now_dt.minute % step != 0 else 0; minutes_to_add = step if minutes_to_add == 0 and (mock_now_dt.second > 0 or mock_now_dt.microsecond > 0) else minutes_to_add; earliest_start_dt = (mock_now_dt + timedelta(minutes=minutes_to_add)).replace(second=0, microsecond=0); expected_mid_slot_start_time = earliest_start_dt.time(); expected_mid_slot_start_time = const.WORKING_HOURS_START if expected_mid_slot_start_time < const.WORKING_HOURS_START else expected_mid_slot_start_time; log.debug(f"Calling calculate_available_slots..."); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, today_date); log.debug(f"Result slots: {result_slots}"); expected_slots = [(expected_mid_slot_start_time, time(14, 0)), (time(15, 0), const.WORKING_HOURS_END)]; log.debug(f"Expected slots: {expected_slots}"); mock_get_bookings.assert_called_once_with(mock_db, today_date); assert result_slots == expected_slots
def test_calculate_slots_today_all_slots_passed(mocker, mock_db, caplog): caplog.set_level(logging.INFO); mock_now_dt = dt_original.datetime(2024, 5, 15, 21, 50, 0); today_date = mock_now_dt.date(); MockDateTime.set_now(mock_now_dt); mock_booking_data = []; mock_get_bookings = mocker.patch.object(booking_service, 'get_bookings_by_date', return_value=mock_booking_data); result_slots = booking_service.calculate_available_slots(mock_db, TEST_EQUIPMENT_ID, today_date); expected_slots = []; assert result_slots == expected_slots; mock_get_bookings.assert_called_once_with(mock_db, today_date)

# --- Тесты для create_booking ---
def test_create_booking_success(mocker, mock_db, caplog):
    caplog.set_level(logging.INFO)
    start_time_str = "14:00"; duration_str = "01:30"; new_booking_id = 999
    # Mock datetime.now()
    mock_now_dt = dt_original.datetime(2024, 5, 15, 10, 0, 0); MockDateTime.set_now(mock_now_dt)
    # Mock conflict check
    mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[])
    # Mock db execute_query to return the ID
    mock_db.execute_query.return_value = [{'id': new_booking_id}]

    # Act
    success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str)

    # Assert
    assert success is True
    assert message == const.MSG_BOOKING_SUCCESS
    assert returned_id == new_booking_id
    # Check conflict call
    expected_start_dt = dt_original.datetime(2024, 5, 15, 14, 0, 0)
    expected_end_dt = dt_original.datetime(2024, 5, 15, 15, 30, 0)
    mock_check_conflict.assert_called_once_with(mock_db, TEST_EQUIPMENT_ID, expected_start_dt, expected_end_dt)
    # Check db call (INSERT)
    assert mock_db.execute_query.call_count == 1 # Only insert query
    last_call = mock_db.execute_query.call_args_list[-1]
    called_query: str = last_call.args[0]; called_params: tuple = last_call.args[1]; called_kwargs: dict = last_call.kwargs
    assert called_query.strip().startswith("INSERT INTO bookings")
    assert called_params[0] == TEST_USER_ID; assert called_params[1] == TEST_EQUIPMENT_ID
    assert called_params[2] == DEFAULT_DATE; assert called_params[3] == expected_start_dt # start_datetime_naive
    assert called_params[4] == expected_end_dt # end_datetime_naive
    assert called_params[5] == "14:00-15:30" # time_interval
    # duration calculation in query
    assert called_params[6] == expected_end_dt # for EXTRACT
    assert called_params[7] == expected_start_dt # for EXTRACT
    assert isinstance(called_params[8], dt_original.datetime) # data_booking_ts
    assert called_kwargs.get('commit') is True
    assert called_kwargs.get('fetch_results') is True
    assert f"Создана ID {new_booking_id}" in caplog.text

# (Параметризованные тесты для create_booking_fail_* остаются без изменений, они выглядят корректно)
@pytest.mark.parametrize("date_str, time_str, duration_str, expected_msg_key", [("15/05/2024", "10:00", "01:00", "MSG_BOOKING_FAIL_INVALID_TIME"), (DEFAULT_DATE_STR, "10-00", "01:00", "MSG_BOOKING_FAIL_INVALID_TIME"), (DEFAULT_DATE_STR, "10:00", "abc:d", "MSG_BOOKING_FAIL_INVALID_TIME"), (DEFAULT_DATE_STR, "10:00", "00:00", "MSG_BOOKING_FAIL_INVALID_TIME"), (DEFAULT_DATE_STR, "10:00", "00:15", "MSG_BOOKING_FAIL_INVALID_TIME"), (DEFAULT_DATE_STR, "10:00", "-01:00","MSG_BOOKING_FAIL_INVALID_TIME"),])
def test_create_booking_fail_invalid_formats_or_duration(mocker, mock_db, date_str, time_str, duration_str, expected_msg_key, caplog): caplog.set_level(logging.WARNING); expected_msg = getattr(const, expected_msg_key, "Unknown error message key"); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict'); mocker.patch('constants.BOOKING_TIME_STEP_MINUTES', 30); mock_now_dt = dt_original.datetime(2024, 5, 15, 9, 0, 0); MockDateTime.set_now(mock_now_dt); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, date_str, time_str, duration_str); assert success is False; assert message == expected_msg; assert returned_id is None; mock_check_conflict.assert_not_called(); mock_db.execute_query.assert_not_called()
def test_create_booking_fail_duration_limit_exceeded(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); start_time_str = "09:00"; mocker.patch('constants.BOOKING_TIME_STEP_MINUTES', 30); max_hours = const.MAX_BOOKING_DURATION_HOURS; duration_str = f"{max_hours:02d}:30"; mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict'); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert message == const.MSG_BOOKING_FAIL_LIMIT_EXCEEDED; assert returned_id is None; mock_check_conflict.assert_not_called(); mock_db.execute_query.assert_not_called(); assert f"{TEST_USER_ID}: лимит" in caplog.text
def test_create_booking_fail_before_work_hours(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); work_start_hour = const.WORKING_HOURS_START.hour; start_time_str = f"{work_start_hour - 1:02d}:30"; duration_str = "01:00"; mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict'); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert message.startswith(const.MSG_BOOKING_FAIL_OUTSIDE_WORK_HOURS.split('{')[0]); assert returned_id is None; mock_check_conflict.assert_not_called(); mock_db.execute_query.assert_not_called(); assert f"Бронь {TEST_USER_ID} вне раб. часов" in caplog.text # ИСПРАВЛЕНО: Проверка лога
def test_create_booking_fail_after_work_hours(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); mocker.patch('constants.BOOKING_TIME_STEP_MINUTES', 30); start_dt = dt_original.datetime.combine(DEFAULT_DATE, const.WORKING_HOURS_END) - timedelta(minutes=15); start_time_str = start_dt.strftime("%H:%M"); duration_str = "00:30"; mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict'); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert message.startswith(const.MSG_BOOKING_FAIL_ENDS_OUTSIDE_WORK_HOURS.split('{')[0]); assert returned_id is None; mock_check_conflict.assert_not_called(); mock_db.execute_query.assert_not_called(); assert f"Бронь {TEST_USER_ID} заканчивается после раб. дня" in caplog.text # ИСПРАВЛЕНО: Проверка лога
def test_create_booking_fail_in_past(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); start_time_str = "08:00"; duration_str = "01:00"; mock_now_dt = dt_original.datetime(2024, 5, 15, 9, 0, 0); MockDateTime.set_now(mock_now_dt); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict'); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert message == const.MSG_BOOKING_FAIL_TIME_IN_PAST; assert returned_id is None; mock_check_conflict.assert_not_called(); mock_db.execute_query.assert_not_called(); assert f"{TEST_USER_ID}: в прошлом" in caplog.text
def test_create_booking_fail_overlap(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); start_time_str = "15:00"; duration_str = "02:00"; mock_now_dt = dt_original.datetime(2024, 5, 15, 10, 0, 0); MockDateTime.set_now(mock_now_dt); conflict_start = dt_original.datetime.combine(DEFAULT_DATE, time(15, 30)); conflict_end = dt_original.datetime.combine(DEFAULT_DATE, time(16, 30)); conflict_user = "Другой Пользователь"; mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[{'id': 55, 'time_start': conflict_start, 'time_end': conflict_end, 'user_fi': conflict_user}]); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert returned_id is None; assert const.MSG_BOOKING_FAIL_OVERLAP in message; assert conflict_user in message; assert "(Занято:" in message; mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_not_called(); assert f"КОНФЛИКТ user {TEST_USER_ID}" in caplog.text
def test_create_booking_fail_check_conflict_error(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); start_time_str = "16:00"; duration_str = "01:00"; mock_now_dt = dt_original.datetime(2024, 5, 15, 10, 0, 0); MockDateTime.set_now(mock_now_dt); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[{'id': -1, 'error': 'check_failed'}]); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert returned_id is None; assert message == "Не удалось проверить время на конфликты. Попробуйте позже."; mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_not_called()
def test_create_booking_fail_insert_error(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); start_time_str = "17:00"; duration_str = "01:00"; mock_now_dt = dt_original.datetime(2024, 5, 15, 10, 0, 0); MockDateTime.set_now(mock_now_dt); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[]); mock_db.execute_query.side_effect = Exception("DB Insert Failed"); success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert returned_id is None; assert message == const.MSG_ERROR_GENERAL; mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_called_once(); assert f"Ошибка при создании бронирования user {TEST_USER_ID}" in caplog.text
def test_create_booking_fail_insert_no_id(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); start_time_str = "18:00"; duration_str = "01:00"; mock_now_dt = dt_original.datetime(2024, 5, 15, 10, 0, 0); MockDateTime.set_now(mock_now_dt); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[]); mock_db.execute_query.return_value = []; success, message, returned_id = booking_service.create_booking(mock_db, TEST_USER_ID, TEST_EQUIPMENT_ID, DEFAULT_DATE_STR, start_time_str, duration_str); assert success is False; assert returned_id is None; assert message == const.MSG_BOOKING_FAIL_GENERAL; mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_called_once(); assert "INSERT" in caplog.text and "не вернул ID" in caplog.text

# --- Тесты для cancel_booking ---
# (Тесты cancel_booking остаются без изменений, они выглядят корректно)
def test_cancel_booking_success_user(mocker, mock_db, caplog): caplog.set_level(logging.INFO); booking_id = BOOKING_ID_FUTURE; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_FUTURE); mock_db.execute_query.return_value = 1; mock_now = dt_original.datetime(2024, 5, 15, 12, 0, 0); MockDateTime.set_now(mock_now); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is True; assert message == const.MSG_BOOKING_CANCELLED; assert owner_id == user_id; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_called_once_with("UPDATE bookings SET cancel = TRUE WHERE id = %s AND cancel = FALSE AND finish IS NULL;", (booking_id,), commit=True, fetch_results=False); assert f"Бронь {booking_id} ({user_id}) отменена пользователем {user_id}" in caplog.text # ИСПРАВЛЕНО: Текст лога
def test_cancel_booking_success_admin(mocker, mock_db, caplog): caplog.set_level(logging.INFO); booking_id = BOOKING_ID_PAST; admin_user_id = TEST_ADMIN_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_PAST); mock_db.execute_query.return_value = 1; mock_now = dt_original.datetime(2024, 5, 15, 9, 30, 0); MockDateTime.set_now(mock_now); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=admin_user_id, is_admin_cancel=True); assert success is True; assert message == const.MSG_BOOKING_CANCELLED; assert owner_id == MOCK_BOOKING_PAST['user_id']; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_called_once(); assert f"Бронь {booking_id} ({MOCK_BOOKING_PAST['user_id']}) отменена администратором {admin_user_id}" in caplog.text # ИСПРАВЛЕНО: Текст лога
def test_cancel_booking_fail_not_found(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_NOT_FOUND_ID; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=None); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == const.MSG_CANCEL_FAIL_NOT_FOUND; assert owner_id is None; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called()
def test_cancel_booking_fail_already_cancelled(mocker, mock_db): booking_id = BOOKING_ID_CANCELLED; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_CANCELLED); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Бронь уже отменена."; assert owner_id == user_id; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called()
def test_cancel_booking_fail_already_finished(mocker, mock_db): booking_id = BOOKING_ID_FINISHED; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_FINISHED); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Бронь уже завершена."; assert owner_id == user_id; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called()
def test_cancel_booking_fail_not_owner(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_OTHER_USER; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_OTHER_USER); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Это не ваше бронирование."; assert owner_id == MOCK_BOOKING_OTHER_USER['user_id']; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called(); assert f"{user_id} пытался отменить чужую {booking_id}" in caplog.text
def test_cancel_booking_fail_too_late(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_PAST; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_PAST); mock_now = dt_original.datetime(2024, 5, 15, 9, 30, 0); MockDateTime.set_now(mock_now); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == const.MSG_CANCEL_FAIL_TOO_LATE; assert owner_id == user_id; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called(); assert f"{user_id} пытался отменить начавш. {booking_id}" in caplog.text
def test_cancel_booking_fail_update_error(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); booking_id = BOOKING_ID_FUTURE; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_FUTURE); mock_db.execute_query.side_effect = Exception("DB Update Failed"); mock_now = dt_original.datetime(2024, 5, 15, 12, 0, 0); MockDateTime.set_now(mock_now); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == const.MSG_ERROR_GENERAL; assert owner_id == user_id; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_called_once(); assert f"Ошибка UPDATE отмены {booking_id}" in caplog.text
def test_cancel_booking_fail_update_zero_rows(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_FUTURE; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', side_effect=[MOCK_BOOKING_FUTURE, {**MOCK_BOOKING_FUTURE, 'cancel': True}]); mock_db.execute_query.return_value = 0; mock_now = dt_original.datetime(2024, 5, 15, 12, 0, 0); MockDateTime.set_now(mock_now); success, message, owner_id = booking_service.cancel_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Бронь уже отменена."; assert owner_id == user_id; assert mock_find.call_count == 2; mock_db.execute_query.assert_called_once(); assert f"Отмена {booking_id}, но не найдена/неактивна (rows=0)" in caplog.text

# --- Тесты для finish_booking ---
# (Тесты finish_booking остаются без изменений, они выглядят корректно)
def test_finish_booking_success(mocker, mock_db, caplog): caplog.set_level(logging.INFO); booking_id = BOOKING_ID_ACTIVE_NOW; user_id = TEST_USER_ID; mock_booking = MOCK_BOOKING_ACTIVE_NOW; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_db.execute_query.return_value = 1; mock_now = dt_original.datetime(2024, 5, 15, 11, 30, 0); MockDateTime.set_now(mock_now); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is True; assert const.MSG_BOOKING_FINISHED in message; assert mock_booking['equipment_name'] in message; assert mock_now.strftime('%H:%M:%S') in message; mock_find.assert_called_once_with(mock_db, booking_id); update_query_start = "UPDATE bookings SET finish = %s"; mock_db.execute_query.assert_called_once(); call_args, call_kwargs = mock_db.execute_query.call_args; assert call_args[0].strip().startswith(update_query_start); assert isinstance(call_args[1][0], dt_original.datetime); assert call_args[1][1] == booking_id; assert call_kwargs.get('commit') is True; assert call_kwargs.get('fetch_results') is False; assert f"{user_id} завершил {booking_id}" in caplog.text
def test_finish_booking_success_just_after_end(mocker, mock_db, caplog): caplog.set_level(logging.INFO); booking_id = BOOKING_ID_PAST; user_id = TEST_USER_ID; mock_booking = MOCK_BOOKING_PAST; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_db.execute_query.return_value = 1; mock_now = MOCK_BOOKING_PAST['time_end'] + timedelta(minutes=1); MockDateTime.set_now(mock_now); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is True; assert const.MSG_BOOKING_FINISHED in message; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_called_once()
def test_finish_booking_fail_not_found(mocker, mock_db): booking_id = BOOKING_NOT_FOUND_ID; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=None); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == const.MSG_FINISH_FAIL_NOT_ACTIVE; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called()
def test_finish_booking_fail_not_owner(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_ACTIVE_NOW; user_id = TEST_OTHER_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_ACTIVE_NOW); mock_now = dt_original.datetime(2024, 5, 15, 11, 30, 0); MockDateTime.set_now(mock_now); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Это не ваше бронирование."; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called(); assert f"{user_id} завершает чужую {booking_id}" in caplog.text
def test_finish_booking_fail_already_cancelled(mocker, mock_db): booking_id = BOOKING_ID_CANCELLED; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_CANCELLED); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Бронь отменена."; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called()
def test_finish_booking_fail_already_finished(mocker, mock_db): booking_id = BOOKING_ID_FINISHED; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_FINISHED); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Бронь завершена."; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called()
def test_finish_booking_fail_not_started_yet(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_FUTURE; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_FUTURE); mock_now = MOCK_BOOKING_FUTURE['time_start'] - timedelta(hours=2); MockDateTime.set_now(mock_now); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == const.MSG_FINISH_FAIL_NOT_ACTIVE; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_not_called(); assert f"Попытка завершить не начавш. {booking_id}" in caplog.text
def test_finish_booking_fail_update_error(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); booking_id = BOOKING_ID_ACTIVE_NOW; user_id = TEST_USER_ID; mock_booking = MOCK_BOOKING_ACTIVE_NOW; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_db.execute_query.side_effect = Exception("DB Update Failed"); mock_now = dt_original.datetime(2024, 5, 15, 11, 30, 0); MockDateTime.set_now(mock_now); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == const.MSG_ERROR_GENERAL; mock_find.assert_called_once_with(mock_db, booking_id); mock_db.execute_query.assert_called_once(); assert f"Ошибка UPDATE завершения {booking_id}" in caplog.text
def test_finish_booking_fail_update_zero_rows(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_ACTIVE_NOW; user_id = TEST_USER_ID; mock_booking = MOCK_BOOKING_ACTIVE_NOW; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', side_effect=[mock_booking, {**mock_booking, 'finish': dt_original.datetime.now()}]); mock_db.execute_query.return_value = 0; mock_now = dt_original.datetime(2024, 5, 15, 11, 30, 0); MockDateTime.set_now(mock_now); success, message = booking_service.finish_booking(mock_db, booking_id, user_id=user_id); assert success is False; assert message == "Бронь уже завершена."; assert mock_find.call_count == 2; mock_db.execute_query.assert_called_once(); assert f"Попытка завершить {booking_id}, но не найдена/неактивна (rows=0)" in caplog.text

# --- Тесты для extend_booking ---
# (Тесты extend_booking остаются без изменений, они выглядят корректно, включая исправления)
def test_extend_booking_success(mocker, mock_db, caplog):
    caplog.set_level(logging.INFO)
    booking_id = BOOKING_ID_TO_EXTEND; user_id = TEST_USER_ID; extension_str = "00:30"; mock_booking = MOCK_BOOKING_TO_EXTEND
    mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking)
    mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[])
    mock_db.execute_query.return_value = 1; mock_now = dt_original.datetime(2024, 5, 15, 14, 45, 0); MockDateTime.set_now(mock_now)
    success, message = booking_service.extend_booking(mock_db, booking_id, user_id, extension_str)
    assert success is True; assert const.MSG_BOOKING_EXTENDED in message; assert mock_booking['equipment_name'] in message
    assert booking_service._format_time(mock_booking['time_end'] + timedelta(minutes=30)) in message
    mock_find.assert_called_once_with(mock_db, booking_id)
    expected_check_start = mock_booking['time_end'].replace(tzinfo=None)
    expected_check_end = (mock_booking['time_end'] + timedelta(minutes=30)).replace(tzinfo=None)
    mock_check_conflict.assert_called_once_with(mock_db, mock_booking['equip_id'], expected_check_start, expected_check_end, exclude_booking_id=booking_id)
    update_query_start = "UPDATE bookings SET time_end ="; mock_db.execute_query.assert_called_once()
    call_args, call_kwargs = mock_db.execute_query.call_args; assert call_args[0].strip().startswith(update_query_start)
    params_dict = call_args[1]; assert params_dict['new_end'] == expected_check_end; assert params_dict['interval'] == "14:00-15:30"; assert params_dict['duration'] == 1.5
    assert params_dict['ext_delta'] == timedelta(minutes=30); assert params_dict['b_id'] == booking_id; assert call_kwargs.get('commit') is True; assert call_kwargs.get('fetch_results') is False; assert f"{user_id} продлил {booking_id}" in caplog.text
@pytest.mark.parametrize("ext_str, expected_error_part", [("abc", "Некорр. формат"), ("1:2", "Некорр. формат"), ("00:00", "Некорр. формат"), ("00:10", "Некорр. формат"), ("-1:00", "Некорр. формат"),])
def test_extend_booking_fail_invalid_extension_str(mocker, mock_db, ext_str, expected_error_part): mocker.patch('constants.BOOKING_TIME_STEP_MINUTES', 30); mock_find = mocker.patch.object(booking_service, 'find_booking_by_id'); success, message = booking_service.extend_booking(mock_db, BOOKING_ID_TO_EXTEND, TEST_USER_ID, ext_str); assert success is False; assert message.startswith(expected_error_part); mock_find.assert_not_called(); mock_db.execute_query.assert_not_called()
def test_extend_booking_fail_booking_not_found(mocker, mock_db): mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=None); success, message = booking_service.extend_booking(mock_db, BOOKING_NOT_FOUND_ID, TEST_USER_ID, "01:00"); assert success is False; assert message == const.MSG_EXTEND_FAIL_NOT_ACTIVE; mock_find.assert_called_once_with(mock_db, BOOKING_NOT_FOUND_ID); mock_db.execute_query.assert_not_called()
def test_extend_booking_fail_not_owner(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_TO_EXTEND); success, message = booking_service.extend_booking(mock_db, BOOKING_ID_TO_EXTEND, TEST_OTHER_USER_ID, "00:30"); assert success is False; assert message == "Это не ваше бронирование."; mock_find.assert_called_once_with(mock_db, BOOKING_ID_TO_EXTEND); mock_db.execute_query.assert_not_called(); assert f"{TEST_OTHER_USER_ID} продляет чужую {BOOKING_ID_TO_EXTEND}" in caplog.text
def test_extend_booking_fail_cancelled(mocker, mock_db): mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_CANCELLED); success, message = booking_service.extend_booking(mock_db, BOOKING_ID_CANCELLED, TEST_USER_ID, "00:30"); assert success is False; assert message == "Бронь отменена."; mock_find.assert_called_once_with(mock_db, BOOKING_ID_CANCELLED); mock_db.execute_query.assert_not_called()
def test_extend_booking_fail_finished(mocker, mock_db): mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_FINISHED); success, message = booking_service.extend_booking(mock_db, BOOKING_ID_FINISHED, TEST_USER_ID, "00:30"); assert success is False; assert message == "Бронь завершена."; mock_find.assert_called_once_with(mock_db, BOOKING_ID_FINISHED); mock_db.execute_query.assert_not_called()
def test_extend_booking_fail_already_ended(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); mock_booking = MOCK_BOOKING_TO_EXTEND; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_now = dt_original.datetime(2024, 5, 15, 15, 10, 0); MockDateTime.set_now(mock_now); success, message = booking_service.extend_booking(mock_db, BOOKING_ID_TO_EXTEND, TEST_USER_ID, "00:30"); assert success is False; assert message == "Бронирование уже завершилось."; mock_find.assert_called_once_with(mock_db, BOOKING_ID_TO_EXTEND); mock_db.execute_query.assert_not_called(); assert f"{TEST_USER_ID} продляет закончившуюся {BOOKING_ID_TO_EXTEND}" in caplog.text
def test_extend_booking_fail_ends_after_work_hours(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); near_end_dt = dt_original.datetime.combine(DEFAULT_DATE, const.WORKING_HOURS_END) - timedelta(minutes=15); mock_booking = { **MOCK_BOOKING_TO_EXTEND, 'time_end': near_end_dt }; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_now = mock_booking['time_end'] - timedelta(minutes=5); MockDateTime.set_now(mock_now); extension_str = "00:30"; success, message = booking_service.extend_booking(mock_db, BOOKING_ID_TO_EXTEND, TEST_USER_ID, extension_str); assert success is False; assert message.startswith(const.MSG_BOOKING_FAIL_ENDS_OUTSIDE_WORK_HOURS.split('{')[0]); mock_find.assert_called_once_with(mock_db, BOOKING_ID_TO_EXTEND); mock_db.execute_query.assert_not_called(); assert f"Продл. {BOOKING_ID_TO_EXTEND} {TEST_USER_ID} > раб. дня" in caplog.text
def test_extend_booking_fail_total_duration_limit(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); max_dur_timedelta = timedelta(hours=const.MAX_BOOKING_DURATION_HOURS); work_end_dt = dt_original.datetime.combine(DEFAULT_DATE, const.WORKING_HOURS_END); start_time = work_end_dt - max_dur_timedelta - timedelta(minutes=45); end_time = start_time + max_dur_timedelta - timedelta(minutes=15); mock_booking = { **MOCK_BOOKING_TO_EXTEND, 'time_start': start_time, 'time_end': end_time }; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_now = end_time - timedelta(minutes=5); MockDateTime.set_now(mock_now); extension_str = "00:30"; success, message = booking_service.extend_booking(mock_db, BOOKING_ID_TO_EXTEND, TEST_USER_ID, extension_str); assert success is False; assert message == const.MSG_BOOKING_FAIL_LIMIT_EXCEEDED; mock_find.assert_called_once_with(mock_db, BOOKING_ID_TO_EXTEND); mock_db.execute_query.assert_not_called(); assert f"{BOOKING_ID_TO_EXTEND}: превышен лимит" in caplog.text
def test_extend_booking_fail_conflict(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_TO_EXTEND; user_id = TEST_USER_ID; extension_str = "01:00"; mock_booking = MOCK_BOOKING_TO_EXTEND; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[MOCK_BOOKING_CONFLICTING_EXTENSION]); mock_now = dt_original.datetime(2024, 5, 15, 14, 45, 0); MockDateTime.set_now(mock_now); success, message = booking_service.extend_booking(mock_db, booking_id, user_id, extension_str); assert success is False; assert const.MSG_BOOKING_FAIL_OVERLAP in message; assert MOCK_BOOKING_CONFLICTING_EXTENSION['user_fi'] in message; assert "(Занято:" in message; mock_find.assert_called_once_with(mock_db, booking_id); mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_not_called(); assert f"Конфликт продления {booking_id}" in caplog.text
def test_extend_booking_fail_check_conflict_error(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); booking_id = BOOKING_ID_TO_EXTEND; user_id = TEST_USER_ID; extension_str = "00:30"; mock_booking = MOCK_BOOKING_TO_EXTEND; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', side_effect=Exception("Check Conflict DB Error")); mock_now = dt_original.datetime(2024, 5, 15, 14, 45, 0); MockDateTime.set_now(mock_now); success, message = booking_service.extend_booking(mock_db, booking_id, user_id, extension_str); assert success is False; assert message == "Ошибка проверки доступности времени."; mock_find.assert_called_once_with(mock_db, booking_id); mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_not_called(); assert f"{booking_id}: Ошибка при вызове check_booking_conflict" in caplog.text
def test_extend_booking_fail_update_error(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); booking_id = BOOKING_ID_TO_EXTEND; user_id = TEST_USER_ID; extension_str = "00:30"; mock_booking = MOCK_BOOKING_TO_EXTEND; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[]); mock_db.execute_query.side_effect = Exception("DB Update Error"); mock_now = dt_original.datetime(2024, 5, 15, 14, 45, 0); MockDateTime.set_now(mock_now); success, message = booking_service.extend_booking(mock_db, booking_id, user_id, extension_str); assert success is False; assert message == const.MSG_ERROR_GENERAL; mock_find.assert_called_once_with(mock_db, booking_id); mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_called_once(); assert f"Ошибка UPDATE продления {booking_id}" in caplog.text
def test_extend_booking_fail_update_zero_rows(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_ID_TO_EXTEND; user_id = TEST_USER_ID; extension_str = "00:30"; mock_booking = MOCK_BOOKING_TO_EXTEND; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_check_conflict = mocker.patch.object(booking_service, 'check_booking_conflict', return_value=[]); mock_db.execute_query.return_value = 0; mock_now = dt_original.datetime(2024, 5, 15, 14, 45, 0); MockDateTime.set_now(mock_now); success, message = booking_service.extend_booking(mock_db, booking_id, user_id, extension_str); assert success is False; assert message == const.MSG_EXTEND_FAIL_NOT_ACTIVE; mock_find.assert_called_once_with(mock_db, booking_id); mock_check_conflict.assert_called_once(); mock_db.execute_query.assert_called_once(); assert f"Продление {booking_id}, но неактивна (rows=0)" in caplog.text

# --- Тесты для confirm_start_booking ---
# (Тесты confirm_start_booking остаются без изменений)
def test_confirm_start_booking_success(mocker, mock_db): booking_id = BOOKING_ID_FUTURE; user_id = TEST_USER_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=MOCK_BOOKING_FUTURE); result = booking_service.confirm_start_booking(mock_db, booking_id, user_id); assert result is True; mock_find.assert_called_once_with(mock_db, booking_id)
@pytest.mark.parametrize("mock_return, user_id_to_check", [(MOCK_BOOKING_OTHER_USER, TEST_USER_ID), (MOCK_BOOKING_CANCELLED, TEST_USER_ID), (MOCK_BOOKING_FINISHED, TEST_USER_ID), (None, TEST_USER_ID)])
def test_confirm_start_booking_fail(mocker, mock_db, mock_return, user_id_to_check, caplog): caplog.set_level(logging.WARNING); booking_id = mock_return['id'] if mock_return else BOOKING_NOT_FOUND_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_return); result = booking_service.confirm_start_booking(mock_db, booking_id, user_id_to_check); assert result is False; mock_find.assert_called_once_with(mock_db, booking_id); assert (f"Попытка подтвердить неактив/чужую {booking_id}" in caplog.text) if mock_return else (f"Не найдена {booking_id} для подтверждения" in caplog.text)

# --- Тесты для auto_cancel_unconfirmed_booking ---
def test_auto_cancel_success(mocker, mock_db, caplog):
    caplog.set_level(logging.INFO)
    booking_id = BOOKING_ID_FUTURE; mock_booking = MOCK_BOOKING_FUTURE
    mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking)
    # Мокируем cancel_booking, чтобы вернуть успех
    mock_cancel = mocker.patch.object(booking_service, 'cancel_booking', return_value=(True, "mock msg", mock_booking['user_id']))
    success, owner_id, equip_name = booking_service.auto_cancel_unconfirmed_booking(mock_db, booking_id)
    assert success is True
    assert owner_id == mock_booking['user_id']
    assert equip_name == mock_booking['equipment_name']
    mock_find.assert_called_once_with(mock_db, booking_id)
    mock_cancel.assert_called_once_with(mock_db, booking_id, user_id=None, is_admin_cancel=True)
    assert f"Бронь {booking_id} подлежит автоотмене" not in caplog.text # Убрали эту проверку из функции
    assert f"Бронь {booking_id} успешно автоматически отменена" in caplog.text

@pytest.mark.parametrize("mock_booking_data, reason_log_part", [
    (MOCK_BOOKING_CANCELLED, "cancel=True"),
    (MOCK_BOOKING_FINISHED, "finish_set=True")
])
def test_auto_cancel_not_needed_already_inactive(mocker, mock_db, mock_booking_data, reason_log_part, caplog):
    caplog.set_level(logging.DEBUG)
    booking_id = mock_booking_data['id']
    mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking_data)
    mock_cancel = mocker.patch.object(booking_service, 'cancel_booking')
    success, owner_id, equip_name = booking_service.auto_cancel_unconfirmed_booking(mock_db, booking_id)
    assert success is False
    assert owner_id == mock_booking_data['user_id']
    assert equip_name == mock_booking_data['equipment_name']
    mock_find.assert_called_once_with(mock_db, booking_id)
    mock_cancel.assert_not_called()
    assert f"Автоотмена для брони {booking_id} не требуется" in caplog.text
    assert reason_log_part in caplog.text

# Отдельный тест для случая, когда время уже наступило (если оставили эту логику)
# Если логику can_auto_cancel убрали, этот тест должен ожидать success=True
# def test_auto_cancel_not_needed_time_started(mocker, mock_db, caplog): ...

def test_auto_cancel_booking_not_found(mocker, mock_db, caplog): caplog.set_level(logging.WARNING); booking_id = BOOKING_NOT_FOUND_ID; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=None); mock_cancel = mocker.patch.object(booking_service, 'cancel_booking'); success, owner_id, equip_name = booking_service.auto_cancel_unconfirmed_booking(mock_db, booking_id); assert success is False; assert owner_id is None; assert equip_name is None; mock_find.assert_called_once_with(mock_db, booking_id); mock_cancel.assert_not_called(); assert f"Не найдена {booking_id} для автоотмены" in caplog.text
def test_auto_cancel_fail_on_cancel_call(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); booking_id = BOOKING_ID_FUTURE; mock_booking = MOCK_BOOKING_FUTURE; mock_find = mocker.patch.object(booking_service, 'find_booking_by_id', return_value=mock_booking); mock_cancel = mocker.patch.object(booking_service, 'cancel_booking', return_value=(False, "DB error", mock_booking['user_id'])); success, owner_id, equip_name = booking_service.auto_cancel_unconfirmed_booking(mock_db, booking_id); assert success is False; assert owner_id == mock_booking['user_id']; assert equip_name == mock_booking['equipment_name']; mock_find.assert_called_once_with(mock_db, booking_id); mock_cancel.assert_called_once(); assert f"Не удалось автоматически отменить бронь {booking_id}" in caplog.text

# --- Тесты для get_bookings_for_notification_schedule ---
# (Тесты get_bookings_for_notification_schedule остаются без изменений)
def test_get_bookings_for_notification_schedule_success(mocker, mock_db, caplog): caplog.set_level(logging.DEBUG); db_return_data = [{'id': BOOKING_ID_FUTURE, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'time_start': MOCK_BOOKING_FUTURE['time_start'], 'time_end': MOCK_BOOKING_FUTURE['time_end'], 'name_equip': 'Обор1'}, {'id': BOOKING_ID_ACTIVE_NOW, 'user_id': TEST_USER_ID, 'equip_id': TEST_EQUIPMENT_ID, 'time_start': MOCK_BOOKING_ACTIVE_NOW['time_start'], 'time_end': MOCK_BOOKING_ACTIVE_NOW['time_end'], 'name_equip': 'Обор2'}, {'id': 701, 'user_id': 102, 'equip_id': 2, 'time_start': "не дата", 'time_end': dt_original.datetime.now() + timedelta(hours=1), 'name_equip': 'Обор4'},]; mock_db.execute_query.return_value = db_return_data; mock_now = dt_original.datetime(2024, 5, 15, 10, 0); MockDateTime.set_now(mock_now); results = booking_service.get_bookings_for_notification_schedule(mock_db); expected_results = [(BOOKING_ID_FUTURE, TEST_USER_ID, TEST_EQUIPMENT_ID, MOCK_BOOKING_FUTURE['time_start'], MOCK_BOOKING_FUTURE['time_end'], 'Обор1'), (BOOKING_ID_ACTIVE_NOW, TEST_USER_ID, TEST_EQUIPMENT_ID, MOCK_BOOKING_ACTIVE_NOW['time_start'], MOCK_BOOKING_ACTIVE_NOW['time_end'], 'Обор2'),]; assert results == expected_results; mock_db.execute_query.assert_called_once(); call_args, call_kwargs = mock_db.execute_query.call_args; assert isinstance(call_args[1][0], dt_original.datetime); assert isinstance(call_args[1][1], dt_original.datetime); assert call_kwargs.get('fetch_results') is True; assert "Неполные/некорр. данные" in caplog.text
def test_get_bookings_for_notification_schedule_empty(mocker, mock_db, caplog): caplog.set_level(logging.DEBUG); mock_db.execute_query.return_value = []; mock_now = dt_original.datetime(2024, 5, 15, 10, 0); MockDateTime.set_now(mock_now); results = booking_service.get_bookings_for_notification_schedule(mock_db); assert results == []; mock_db.execute_query.assert_called_once(); assert "Найдено 0 броней" in caplog.text
def test_get_bookings_for_notification_schedule_db_error(mocker, mock_db, caplog): caplog.set_level(logging.ERROR); mock_db.execute_query.side_effect = Exception("DB Error"); mock_now = dt_original.datetime(2024, 5, 15, 10, 0); MockDateTime.set_now(mock_now); results = booking_service.get_bookings_for_notification_schedule(mock_db); assert results == []; mock_db.execute_query.assert_called_once(); assert "Ошибка get_bookings_for_notification_schedule" in caplog.text